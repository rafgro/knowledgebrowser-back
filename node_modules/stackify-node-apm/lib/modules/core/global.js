'use strict'

const Logger = require('./../../logger')
const Util = require('../../util')
const STOPPED = 3

/**
 * Instrumentation for global module (currently a placeholder).
 * @param globalModule
 * @param tracer
 * @param shimmer
 * @param packageVersion
 */
module.exports = function (globalModule, tracer, shimmer, packageVersion) {
  Logger.debug('load global module patching')

  // Fatal exception reference
  // - https://github.com/nodejs/node/blob/5877836a33c23dfa591f75005182fb4ab379bcdc/lib/internal/bootstrap/node.js
  // - https://github.com/nodejs/node/blob/1a2cf6696fa59c9723c423c4ff4c1167ab82155c/lib/domain.js
  // `_fatalException` is an undocumented feature of domains, introduced in
  // Node.js v0.8. We use `_fatalException` because wrapping it will not
  // potentially change the behavior of the server unlike listening for
  // `uncaughtException`.
  shimmer.wrap(process, '_fatalException', function wrapFatalException (original) {
    return function wrappedFatalException (error) {
      if (tracer) {
        Logger.debug('Hook:process._fatalException - Uncaught exception raised - Error: %s', error.message)
        Logger.debug('Hook:process._fatalException - Flushing queue')
        tracer.addErrorToActiveTransaction(error)
        tracer.forceFlushQueue()
      }
      return original.apply(this, arguments)
    }
  })

  /**
   * Instrument process emit function in order to track unhandled promise rejections
   * and add it to the current tranasction or the transaction being passed
   */
  shimmer.wrap(process, 'emit', function wrapEmit (original) {
    return function wrappedEmit (ev, error, promise) {
      if (ev === 'unhandledRejection' && error) {
        if (process.listenerCount('unhandledRejection') === 0) {
          const transaction = promise.spanInContext
            ? promise.spanInContext.getTransaction()
            : undefined
          Logger.debug('Hook:process.emit - Captured unhandled rejection for transaction %s', transaction && transaction.id())
          tracer.addErrorToActiveTransaction(error, transaction)
        }
      }
      return original.apply(this, arguments)
    }
  })
  // We are instrumenting the function of the promise library when it is getting resolved
  // or rejected and once finally being executed binding the context or active span
  // to the callback. This is somewhat a hack just to preserve the span for the duration of the promise
  // The adding of the spanInContext in the Promise object is happening on tracer.bindSpanCallback
  if (globalModule.Promise && globalModule.Promise.prototype && globalModule.Promise.prototype.then) {
    shimmer.wrap(globalModule.Promise.prototype, 'then', function wrapThen (original) {
      return makeWrapThen(original)
    })
  }
  if (globalModule.Promise && globalModule.Promise.prototype && globalModule.Promise.prototype.catch) {
    shimmer.wrap(globalModule.Promise.prototype, 'catch', function wrapCatch (original) {
      return makeWrapThen(original, true)
    })
  }
  if (globalModule.Promise && globalModule.Promise.prototype && globalModule.Promise.prototype.finally) {
    shimmer.wrap(globalModule.Promise.prototype, 'finally', function wrapFinally (original) {
      return makeWrapThen(original)
    })
  }
  function makeWrapThen (original, wrapAll) {
    return function wrappedThen () {
      let args = Util.argsToArray.apply(this, arguments)
      let self = this
      if (typeof this.spanInContext !== 'undefined' &&
        typeof args[0] !== 'undefined' &&
        Util.isFunction(args[0]) && !Util.isMonkeyPatched(args[0])) {
        let wrappedCallback = shimmer.wrap(args, 0, function wrapCallback (original) {
          return function wrappedCallback () {
            if (self.spanInContext.state !== STOPPED) {
              tracer.endSpan(self.spanInContext)
            }
            return tracer.bindSpanCallback(original, self.spanInContext).apply(this, arguments)
          }
        })
        if (typeof wrappedCallback !== 'undefined') {
          args[0] = wrappedCallback
        } else {
          Logger.error('Promise.then - makeWrapThen - Unable to wrap the callback')
        }
      }

      if (wrapAll) {
        if (typeof this.spanInContext !== 'undefined' &&
          typeof args[1] !== 'undefined' &&
          Util.isFunction(args[1]) && !Util.isMonkeyPatched(args[1])) {
          let wrappedCallback = shimmer.wrap(args, 1, function wrapCallback (original) {
            return function wrappedCallback () {
              if (self.spanInContext.state !== STOPPED) {
                tracer.endSpan(self.spanInContext)
              }
              return tracer.bindSpanCallback(original, self.spanInContext).apply(this, arguments)
            }
          })
          if (typeof wrappedCallback !== 'undefined') {
            args[1] = wrappedCallback
          } else {
            Logger.error('Promise.then - makeWrapThen - Unable to wrap the callback')
          }
        }
      }
      return original.apply(this, args)
    }
  }
}
