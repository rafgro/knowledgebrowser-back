'use strict'

const Logger = require('../logger')
let semver = require('semver')
let Util = require('../util')

module.exports = function (redis, tracer, shimmer, version) {
  if (!semver.satisfies(version, '^2.0.0')) {
    Logger.debug('redis version %s not supported', version)
    return redis
  }

  Logger.debug('RedisClient version %s', version)

  let proto = redis.RedisClient && redis.RedisClient.prototype
  if (semver.satisfies(version, '>2.5.3')) {
    shimmer.wrap(proto, 'internal_send_command', wrappedInternalSendCommand)
  } else {
    shimmer.wrap(proto, 'send_command', wrapSendCommand)
  }

  return redis

  function wrappedInternalSendCommand (original) {
    return function wrappedInternalSendCommand (commandObj) {
      if (commandObj && commandObj.command) {
        let cb = commandObj.callback
        if (Util.isMonkeyPatched(cb)) {
          Logger.debug('Redis:internal_send_command - callback already wrapped, not binding')
          return original.apply(this, arguments)
        }

        let span = tracer.createSpan('redis.query')
        if (span) {
          span.addProperty('PROVIDER', 'Redis')
          span.addProperty('CATEGORY', 'Cache')
          span.addProperty('SUBCATEGORY', 'Execute')
          span.addProperty('THREAD_ID', this.threadId)
          span.addProperty('OPERATION', commandObj.command)
          if (commandObj.args !== undefined && commandObj.args.length > 0) {
            span.addProperty('CACHEKEY', commandObj.args[0])
          }

          if (cb) {
            commandObj.callback = tracer.bindSpanCallback(function wrappedCallback () {
              tracer.endSpan(span)
              if (cb) {
                return cb.apply(this, arguments)
              }
            }, span)
          }
        }
      }
      return original.apply(this, arguments)
    }
  }

  function wrapSendCommand (original) {
    return function wrappedSendCommand (command) {
      let args = Util.argsToArray.apply(this, arguments)

      var index = args.length - 1
      var cb = args[index]
      let callback

      if (typeof cb === 'function') {
        callback = args[index]
      } else if (Array.isArray(cb) && typeof cb[cb.length - 1] === 'function') {
        callback = cb[cb.length - 1]
      }

      if (callback && Util.isMonkeyPatched(callback)) {
        Logger.debug('Redis:send_command - callback already wrapped, not binding')
        return original.apply(this, arguments)
      }

      const span = tracer.createSpan('redis.query')
      if (span && args.length > 0) {
        span.addProperty('PROVIDER', 'Redis')
        span.addProperty('CATEGORY', 'Cache')
        span.addProperty('SUBCATEGORY', 'Execute')
        span.addProperty('COMPONENT_CATEGORY', 'Cache')
        span.addProperty('COMPONENT_DETAIL', 'Execute')
        span.addProperty('THREAD_ID', this.threadId)
        span.addProperty('OPERATION', command)
        if (typeof args[1][0] === 'string') {
          span.addProperty('CACHEKEY', args[1][0])
        }
        if (typeof cb === 'function') {
          args[index] = tracer.bindSpanCallback(function wrappedCallback () {
            tracer.endSpan(span)
            return cb.apply(this, arguments)
          }, span)
        } else if (Array.isArray(cb) && typeof cb[cb.length - 1] === 'function') {
          var cb2 = cb[cb.length - 1]
          cb[cb.length - 1] = tracer.bindSpanCallback(function wrappedCallback () {
            tracer.endSpan(span)
            return cb2.apply(this, arguments)
          }, span)
        } else {
          var obCb = tracer.bindSpanCallback(function wrappedCallback () {
            tracer.endSpan(span)
          }, span)
          if (typeof args[index] === 'undefined') {
            args[index] = obCb
          } else {
            args.push(obCb)
          }
        }
      }

      return original.apply(this, args)
    }
  }
}
