'use strict'

const Util = require('../util')
const URL = require('url')

/**
 * Wraps http/https remote call
 * @param tracer
 * @param call
 */
module.exports.wrapRemoteRequestCall = function (tracer, call) {
  return function wrapRemoteRequestCall (original) {
    return function wrappedRemoteRequestCall () {
      let args = Util.argsToArray.apply(this, arguments)
      let currentCall = call

      if (Util.isFunction(args[1])) {
        if (typeof args[1].fromGet !== 'undefined') {
          currentCall = args[1].fromGet.slice(0)
          delete args[1].fromGet
        }
      }

      let span = tracer.createSpan(currentCall)
      if (Util.isFunction(args[1]) && span) {
        args[1] = tracer.bindSpanCallback(args[1], span, call + ' - Callback')
      }

      let req = tracer.bindSpanCallback(function boundRequest () {
        let req = original.apply(this, args)
        if (span) {
          tracer.bindEmitter(req)

          let protocol = req.agent && req.agent.protocol
          let host = req._headers.host
          let path = Util.removeQueryString(req.path)
          let url = URL.parse(protocol + '//' + host + '' + path)

          span.addProperty('URL', Util.removeTrailingSlash(url.href))
          span.addProperty('METHOD', req.method)
          span.addProperty('CATEGORY', 'Web External')
          span.addProperty('SUBCATEGORY', 'Execute')
          span.addProperty('COMPONENT_CATEGORY', 'Web External')
          span.addProperty('COMPONENT_DETAIL', 'Execute')

          req.on('response', onResponse)
        }
        return req
      }, span, call).apply(this, args)

      return req

      function onResponse (response) {
        if (span) {
          tracer.bindEmitter(response)
          span.addProperty('STATUS', response.statusCode)
        }

        // Inspired by:
        // https://github.com/nodejs/node/blob/9623ce572a02632b7596452e079bba066db3a429/lib/events.js#L258-L274
        if (response.prependListener) {
          // Added in Node.js 6.0.0
          response.prependListener('end', onEnd)
        } else {
          var existing = response._events && response._events.end
          if (!existing) {
            response.on('end', onEnd)
          } else {
            if (typeof existing === 'function') {
              response._events.end = [onEnd, existing]
            } else {
              existing.unshift(onEnd)
            }
          }
        }

        function onEnd () {
          if (span) {
            tracer.endSpan(span)
          }
        }
      }
    }
  }
}
