'use strict'

const httpCommon = require('./http-common')
const Util = require('../util')
const Logger = require('../logger')
const URL = require('url')
const endOfStream = require('end-of-stream')
const semver = require('semver')

const SHOULD_WRAP_HTTPS = semver.satisfies(process.version, '>=9.0.0 || 8.9.0')
/**
 * http module instrumentation
 * https://nodejs.org/api/http.html
 * @param http
 * @param tracer
 * @param shimmer
 * @param version
 */
module.exports = function (http, tracer, shimmer, version, name) {
  const IS_HTTPS = name === 'https'

  shimmer.wrap(http && http.Server && http.Server.prototype, 'emit', wrapEmit)

  if (http && http.ServerResponse && http.ServerResponse.prototype) {
    Logger.debug('Shimming http@writeHead')
    shimmer.wrap(http.ServerResponse.prototype, 'writeHead', wrapWriteHead)
  }
  if (!IS_HTTPS) {
    tracer.httpPatched = true
  }
  // As of node 0.8, http.request() is the right way to originate outbound
  // requests. From 0.11 until 9, the `https` modulew simply called through to
  // the `http` methods, so to prevent double-instrumenting we need to check
  // what module we're instrumenting and what version of Node we're on. This
  // change originally also appeared in 8.9.0 but was reverted in 8.9.1.
  //
  // TODO: Remove `SHOULD_WRAP_HTTPS` after deprecating Node <9.
  if (SHOULD_WRAP_HTTPS || !IS_HTTPS || (IS_HTTPS && !tracer.httpPatched)) {
    Logger.debug('Shimming http request')
    shimmer.wrap(http, 'request', httpCommon.wrapRemoteRequestCall(tracer, (!IS_HTTPS ? 'http' : 'https') + '.request.external'))
  } else {
    Logger.debug('Shimming http request proxy')
    shimmer.wrap(http, 'request', function wrapHttpGet (original) {
      return function wrappedHttpGet () {
        let args = Util.argsToArray.apply(this, arguments)
        // Lets secretly hide a property that helps determine the call
        if (Util.isFunction(args[1]) && typeof args[1].fromGet === 'undefined') {
          args[1].fromGet = (!IS_HTTPS ? 'http' : 'https') + '.request.external'
        }
        return tracer.bindSpanCallback(original, undefined, 'http.request.external - ' + (args[0] ? args[0] : ' No url')).apply(this, args)
      }
    })
  }
  if ((!IS_HTTPS && semver.satisfies(process.version, '>=8')) || (IS_HTTPS && SHOULD_WRAP_HTTPS)) {
    Logger.debug('Shimming http get')
    shimmer.wrap(http, 'get', httpCommon.wrapRemoteRequestCall(tracer, (!IS_HTTPS ? 'http' : 'https') + '.get.external'))
  } else {
    Logger.debug('Shimming http get proxy')
    shimmer.wrap(http, 'get', function wrapHttpGet (original) {
      return function wrappedHttpGet () {
        let args = Util.argsToArray.apply(this, arguments)
        // Lets secretly hide a property that helps determine the call
        if (Util.isFunction(args[1])) {
          args[1].fromGet = (!IS_HTTPS ? 'http' : 'https') + '.get.external'
        }
        return tracer.bindSpanCallback(original, undefined, 'http.get.external - ' + (args[0] ? args[0] : ' No url')).apply(this, args)
      }
    })
  }

  return http

  /**
   * Wrap http request start
   * @param original
   */
  function wrapEmit (original) {
    return function wrappedEmit (event, req, res) {
      if (event === 'request') {
        return tracer.runInTransaction((IS_HTTPS ? 'https.request' : 'http.request'), wrappedRequestEmit).apply(this, arguments)
      }

      return original.apply(this, arguments)

      function wrappedRequestEmit (event, req, res) {
        tracer.bindEmitter(req)
        tracer.bindEmitter(res)
        let span = tracer.getActiveSpan()

        if (span) {
          // We know if a span is created successfully after a transaction
          createTransactionInfo(span.getTransaction(), req, res)
          span.addProperty('METHOD', req.method)
          let url = URL.parse((req.connection.encrypted ? 'https' : 'http') + '://' + req.headers.host + req.url)
          span.addProperty('URL', Util.removeTrailingSlash(url.href))
        }
        endOfStream(res, endOfStreamCallback)
        function endOfStreamCallback (err) {
          let txInfo = res.txInfo || null
          if (txInfo) {
            for (var i = txInfo.spanStack.length - 1; i >= 0; --i) {
              tracer.endSpan(txInfo.spanStack[i])
            }
          }
          Logger.debug('Instrumentation:HTTP:endRequest - Request has ended')
          if (err) {
            Logger.debug('Instrumentation:HTTP:endRequest - transaction has ended early', err)
            tracer.endTransaction()
          }
          let activeSpan = tracer.getActiveRootSpan()
          if (activeSpan) {
            activeSpan.addProperty('STATUS', res.statusCode)
            tracer.endTransaction()
          }
        }
        try {
          return original.apply(this, arguments)
        } catch (err) {
          tracer.addErrorToActiveTransaction(err)
          endOfStreamCallback(err)
          throw err
        }
      }
    }
  }

  /**
   * Stores transaction info in request and
   * response objects
   * @param {*} transaction
   * @param {*} request
   * @param {*} response
   */
  function createTransactionInfo (transaction, request, response) {
    if (!request || !response) {
      Logger.debug('Missing request or response object! Not storing transaction info.')
      return
    }

    var txInfo = {
      transaction: transaction,
      spanStack: [], // Need to observe
      errorHandled: false,
      error: null
    }
    request['txInfo'] = response['txInfo'] = txInfo // Make this into constant

    Logger.debug(
      'Stored transaction %s information on request and response',
      transaction.id()
    )
  }

  /**
   * Wrap write head to inject the stackify id for unit testing
   * @param {*} original
   */
  function wrapWriteHead (original) {
    return function wrappedWriteHead () {
      let activeTransaction = tracer.getActiveTransaction()
      let stackifyId

      if (activeTransaction) {
        stackifyId = tracer.getStackifyId(activeTransaction.id())
      } else {
        Logger.debug('Http.ServerResponse.writeHead - No active transaction found')
      }

      if (!stackifyId && this.txInfo) {
        stackifyId = tracer.getStackifyId(this.txInfo.transaction.id())
      } else {
        Logger.debug('Http.ServerResponse.writeHead - No transaction info found')
      }

      if (stackifyId) {
        this.setHeader('X-StackifyID', stackifyId)
      }
      return original.apply(this, arguments)
    }
  }
}
