'use strict'
const https = require('https')
const Util = module.exports = {

  /**
   * Generate v4 UUID
   * @returns {string}
   */
  makeId: function makeId () {
    let uuid = ''
    let i
    let random
    for (i = 0; i < 32; i++) {
      random = Math.random() * 16 | 0

      if (i === 8 || i === 12 || i === 16 || i === 20) {
        uuid += '-'
      }
      uuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16)
    }
    return uuid
  },

  /**
   * Retruns value with trailing slash removed.
   * @param value
   * @returns {*}
   */
  removeTrailingSlash: function (value) {
    if (value) {
      return value.replace(/\/$/, '')
    }
    return value
  },

  removeQueryString: function (value) {
    if (value) {
      let queryIndex = value.indexOf('?')
      if (queryIndex === -1) {
        return value
      }
      return value.substring(0, queryIndex)
    }
    return value
  },

  /**
   * Determines if the given object exists and is a function.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a function, else false.
   */
  isFunction: function isFunction (obj) {
    return typeof obj === 'function'
  },

  /**
   * This is the preferred function, when used with `.apply`, for converting the
   * `arguments` object into an actual `Array` as it will not cause deopts.
   *
   * @return {Array} An array containing the elements of `arguments`.
   *
   * @see https://github.com/petkaantonov/bluebird/wiki/Optimization-killers
   */
  argsToArray: function argsToArray () {
    let len = arguments.length
    let arr = new Array(len)
    for (let i = 0; i < len; ++i) {
      arr[i] = arguments[i]
    }
    return arr
  },

  /**
   * Determines if the given object exists and is an array.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is an array, else false.
   */
  isArray: function isArray (obj) {
    return obj instanceof Array
  },

  /**
   * Determine the name of an object.
   *
   * @param {*} obj - The object to get a name for.
   *
   * @return {string} The name of the object if it has one, else `<anonymous>`.
   */
  getObjectName: function getObjectName (obj) {
    return String((!obj || obj === true) ? obj : (obj.name || '<anonymous>'))
  },

  /**
   * Ensures the given index is a valid index inside the array.
   *
   * A negative index value is converted to a positive one by adding it to the
   * array length before checking it.
   *
   * @param {number} arrayLength  - The length of the array this index is for.
   * @param {number} idx          - The index to normalize.
   *
   * @return {?number} The adjusted index value if it is valid, else `null`.
   */
  normalizeIndex: function normalizeIndex (arrayLength, idx) {
    if (idx < 0) {
      idx = arrayLength + idx
    }
    return (idx < 0 || idx >= arrayLength) ? null : idx
  },

  /**
   * Checks if the function/object-function is wrapped by the shimmer
   * Shimmer adds a property if the function is wrapped ('__wrapped')
   *
   * @param {Object}
   * @param {?Function}
   *
   * @returns {boolean}
   */
  isMonkeyPatched: function isMonkeyPatched (object, method) {
    if (!object) {
      return false
    }

    if (!method) {
      return typeof object['__wrapped'] !== 'undefined' && object['__wrapped']
    }

    return typeof object[method] !== 'undefined' && typeof object[method]['__wrapped'] !== 'undefined' && object[method]['__wrapped']
  },

  /**
   * Determines if the given object is a number literal.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a number literal, else false.
   */
  isNumber: function isNumber (obj) {
    return typeof obj === 'number'
  },

  /**
   * Match arity of the wrapped function based on the original function
   * Starting in what we believe to be Node v4 you can set the name and length of
   * a function as properties. This is more ideal than wrapping a function.
   */
  matchArity: function matchArity (original, wrapper) {
    var toDefine = {
      name: { value: original.name },
      length: { value: original.length }
    }

    Object.defineProperties(wrapper, toDefine)

    return wrapper
  },

  /**
   * Takes a string or Array of string objects and returns a comman separated string
   * @param path string or array of strings
   */
  formatPath: function formatPath (path) {
    let formattedPath = path
    if (path) {
      if (Array.isArray(path)) {
        formattedPath = path.join('|')
      }
    }
    return formattedPath
  },

  /**
   * Determines if the given object is a promise instance.
   *
   * @memberof Shim.prototype
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a promise, else false.
   */
  isPromise: function isPromise (obj) {
    return obj && typeof obj.then === 'function'
  },

  /**
   * Determines if the object wrapped is an object function or
   * a raw callback
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is raw callback being wrapped
   */
  isWrappedFunction: function isWrappedFunction (obj) {
    return obj && typeof obj['__isFunction'] !== 'undefined' && obj['__isFunction']
  },

  /**
   * Determines if the given object is undefined.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is undefined, else false.
   */
  isUndefined: function isUndefined (obj) {
    return typeof obj === 'undefined'
  },

  /**
   * Gets the original function if it is wrapped
   * @param {*} obj - The object to check.
   *
   * @return {Function} Returns original function if wrapped else just the passed object
   */
  getOriginalFunction: function getOriginalFunction (obj) {
    return obj && typeof obj['__original'] !== 'undefined' ? obj['__original'] : obj
  },

  getPropertyFromObject: function getPropertyFromObject (obj, property) {
    return typeof obj[property] !== 'undefined' ? obj[property] : undefined
  },

  /**
   * Determines if the given object is an actual object.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is an actual object, else false.
   */
  isObject: function isObject (obj) {
    if (obj === null) {
      return false
    }
    return typeof obj === 'object'
  },

  /**
   * Determines if the given object is an array or collection of array
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the given object is an array or collection of array, else false.
   */
  checkArrayOfFunctionsForever: function checkArrayOfFunctionsForever (routeName) {
    let result = false
    if (Util.isArray(routeName)) {
      for (let i = 0; i < routeName.length; ++i) {
        if (Util.isArray(routeName[i])) {
          result = checkArrayOfFunctionsForever(routeName[i])
        } else if (Util.isFunction(routeName[i])) {
          result = true
        }
        if (result) {
          break
        }
      }
    }
    return result
  },

  /**
   * Parses a route object and get its string version
   *
   * @param {RegExp|string} route - The object to check.
   *
   * @return {string}
   */
  parseRoute: function parseRoute (route) {
    return route instanceof RegExp ? '/' + route.source + '/'
      : typeof route === 'string' ? route
        : '<unknown>'
  },

  /**
   * Determines if the given object is a string.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a string, else false.
   */
  isString: function isString (obj) {
    return typeof obj === 'string'
  },

  /**
   * Determines if the given object is a boolean.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a boolean, else false.
   */
  isBoolean: function isBoolean (obj) {
    return typeof obj === 'boolean'
  },
  /**
   * Gets content from a specific URL with UTF-8 encoding
   * @param {*} url
   * @returns {Promise}
   */
  httpGetSecure: function (url) {
    return new Promise((resolve, reject) => {
      https.get(url, res => {
        let body = ''
        res.setEncoding('utf8')
        res.on('data', function (chunk) {
          body += chunk
        })
        res.on('end', function end () {
          resolve(body)
        })
      }).on('error', reject)
    })
  },

  /**
   * Determines if the given object is a stream object.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a a stream object, else false.
   */
  isStream: function isStream (obj) {
    return obj && obj.emit && Util.isFunction(obj.emit)
  }
}
